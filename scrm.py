import bitarray
import numpy as np
import math
import os
import sh
import itertools
import logging
import sys

logger = logging.getLogger(__name__)

scrm = sh.Command(os.environ['SCRM_PATH'])

def hmm_data_set(positions, haps):
    gaps = positions[1:] - positions[:-1]
    print("Minimum gap: %d" % np.min(gaps))
    print("Average gap: %d" % np.mean(gaps))
    print("# seg. sites: %d" % gaps.shape[0])
    i = np.argmin(gaps)
    print(positions[(i-3):(i+3)])

def parse_scrm(n, L, output):
    cmd_line, seed, _, _, segsites = [line.strip() for line in itertools.islice(output, 5)]
    positions = next(output).strip()
    if positions:
        positions = (L * np.array([float(x) for x in positions.split(" ")[1:]])).astype('int')
        # ignore trailing newline
        haps = [bitarray.bitarray(str(line).strip()) for line in output if line.strip()] 
        return (L, positions, haps)
    return None

def simulate(n, N0, theta, rho, L, demography=[]):
    r = 4 * N0 * rho * (L - 1)
    t = 4 * N0 * theta * L
    args = [n, 1, '-p', int(math.log10(L)) + 1, '-t', t, '-r', r, L, '-l', 
            10000, '-seed', np.random.randint(0, sys.maxint)] + demography
    output = scrm(*args, _iter=True)
    return parse_scrm(n, L, output)

def hmm_data_format(dataset, distinguished_cols):
    # Convert a dataset generated by simulate() to 
    # the format accepted by the inference code
    ret = []
    p = 0
    L, positions, haps = dataset
    for i, pos in enumerate(positions):
        pp = pos - p
        if pp == 0:
            logger.warn("Tri-allelic site at position %d; ignoring" % pos)
            continue
        if pp > 1:
            ret.append([pp - 1, 0, 0])
        d = sum([haps[c][i] for c in distinguished_cols])
        t = sum([h[i] for h in haps])
        ret.append([1, d, t - d])
        p = pos
    if L > pos:
        ret.append([L - pos, 0, 0])
    return np.array(ret)

if __name__ == "__main__":
    L = 1000000
    data = simulate(50, 10000.0, 1e-8, 1e-8, L, ['-n', 1, 1])
    hmmd = hmm_data_format(data, (0, 1))
