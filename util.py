import numpy as np
import functools
import itertools

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx
    args = [iter(iterable)] * n
    return itertools.izip_longest(fillvalue=fillvalue, *args)

def unpack(iterable):
    for span, x in iterable:
        for i in range(span):
            yield x

def pack(seq):
    iterable = iter(seq)
    x = next(iterable)
    i = 1
    for xp in iterable:
        if xp == x:
            i += 1
        else:
            yield (i, x)
            x = xp
            i = 1
    yield (i, x)

def memoize(obj):
    cache = obj.cache = {}
    @functools.wraps(obj)
    def memoizer(*args, **kwargs):
        key = tuple(args) + tuple(kwargs.items())
        if key not in cache:
            cache[key] = obj(*args, **kwargs)
        return cache[key]
    return memoizer

def dataset_from_panel(dataset, n, distinguished_rows):
    L, positions, haps = dataset[:3]
    if n < haps.shape[0]:
        panel = haps[[i for i in range(haps.shape[0]) if i not in distinguished_rows]]
        N, K = panel.shape
        h2 = np.zeros([n, K], dtype=np.uint8)
        h2[:2] = haps[list(distinguished_rows)]
        for i in range(K):
            inds = np.random.permutation(N)
            h2[2:, i] = panel[:, i][np.random.permutation(N)[:(n - 2)]]
        distinguished_rows = (0, 1)
        haps = h2
    seg = haps.sum(axis=0) >= 0
    return (L, positions[seg], haps[:, seg]) + dataset[3:]

def hmm_data_format(dataset, n, distinguished_rows):
    # Convert a dataset generated by simulate() to 
    # the format accepted by the inference code
    # If n < dataset[3].shape[0] then at each site,
    # the undistinguished lineages are chosen by sampling
    # without replacement ("panel mode")
    ret = []
    p = 0
    L, positions, haps = dataset_from_panel(dataset, n, distinguished_rows)[:3]
    if n < haps.shape[0]:
        panel = haps[[i for i in range(haps.shape[0]) if i not in distinguished_rows]]
        N, K = panel.shape
        h2 = np.zeros([n, K], dtype=np.uint8)
        h2[:2] = haps[list(distinguished_rows)]
        for i in range(K):
            inds = np.random.permutation(N)
            h2[2:, i] = panel[:, i][np.random.permutation(N)[:(n - 2)]]
        distinguished_rows = (0, 1)
        haps = h2
    d = haps[list(distinguished_rows)].sum(axis=0)
    t = haps.sum(axis=0)
    nd = d.shape[0]
    nrow = 2 * nd - 1
    ret = np.zeros([nrow, 3], dtype=int)
    ret[::2, 0] = 1
    ret[::2, 1] = d
    ret[::2, 2] = t - d
    gaps = positions[1:] - positions[:-1] - 1
    ret[1::2, 0] = gaps
    ret[1::2, 1:] = 0
    if positions[0] > 0:
        ret = np.vstack(([positions[0], 0, 0], ret))
    if positions[-1] < L - 1:
        ret = np.vstack((ret, [L - 1 - positions[-1], 0, 0]))
    # eliminate "no gaps"
    ret = ret[ret[:, 0] > 0]
    assert np.all(ret >= 0)
    assert ret.sum(axis=0)[0] == L
    ret = np.array(ret, dtype=np.int32)
    assert ret.sum(axis=0)[0] == L
    assert np.all(ret >= 0)
    assert np.all(ret[:, 0] >= 1)
    return ret
